# Review readme and codebase for app setup
_Exported on 13/11/2025 at 8:36:26 GMT+5:30 from Cursor (2.0.75)_

---

**User**

@readme.md (1-155) GO THROUGH THIS README AND GO TRHOUGH THE ENITRE CODEBASE DIRECTORY , MAKE SURE TO GO ONE STEP BY STEP AND BE SIMPLE AND SPECIFIC TOWARDS THE APPROACH , LEAVE THE llm-chat-export for now , focus on the implementation and gettinf the app run locally,

the app realted files should be in the src forlder and the feature testing should be in the test-cases

this readme file that i have provided in the context has all the requirements for the app , make sure to be thorough  

---

**Cursor**


Reviewing the codebase structure, then implementing step by step.



Creating the initial todo list and starting implementation:



Building the application step by step. Starting with the project structure and core setup:


```plaintext
fastapi==0.104.1
uvicorn==0.24.0
sqlalchemy==2.0.23
pydantic==2.5.0
python-dateutil==2.8.2

```

```python
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker

# SQLite database
SQLALCHEMY_DATABASE_URL = "sqlite:///./boostly.db"

engine = create_engine(
    SQLALCHEMY_DATABASE_URL, connect_args={"check_same_thread": False}
)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

Base = declarative_base()

def get_db():
    """Dependency to get database session"""
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

```

```python
from sqlalchemy import Column, Integer, String, DateTime, ForeignKey, CheckConstraint
from sqlalchemy.orm import relationship
from datetime import datetime
from database import Base

class Student(Base):
    __tablename__ = "students"
    
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String, nullable=False)
    email = Column(String, unique=True, index=True, nullable=False)
    current_balance = Column(Integer, default=100, nullable=False)
    monthly_sending_limit = Column(Integer, default=100, nullable=False)
    last_reset_date = Column(DateTime, default=datetime.now)
    
    # Relationships
    sent_recognitions = relationship("Recognition", foreign_keys="Recognition.sender_id", back_populates="sender")
    received_recognitions = relationship("Recognition", foreign_keys="Recognition.receiver_id", back_populates="receiver")
    redemptions = relationship("Redemption", back_populates="student")
    
    __table_args__ = (
        CheckConstraint('current_balance >= 0', name='check_balance_non_negative'),
        CheckConstraint('monthly_sending_limit >= 0', name='check_sending_limit_non_negative'),
    )

class Recognition(Base):
    __tablename__ = "recognitions"
    
    id = Column(Integer, primary_key=True, index=True)
    sender_id = Column(Integer, ForeignKey("students.id"), nullable=False)
    receiver_id = Column(Integer, ForeignKey("students.id"), nullable=False)
    credits = Column(Integer, nullable=False)
    message = Column(String, nullable=True)
    created_at = Column(DateTime, default=datetime.now)
    month_year = Column(String, nullable=False)  # Format: "YYYY-MM" for tracking monthly limits
    
    # Relationships
    sender = relationship("Student", foreign_keys=[sender_id], back_populates="sent_recognitions")
    receiver = relationship("Student", foreign_keys=[receiver_id], back_populates="received_recognitions")
    endorsements = relationship("Endorsement", back_populates="recognition", cascade="all, delete-orphan")
    
    __table_args__ = (
        CheckConstraint('credits > 0', name='check_credits_positive'),
        CheckConstraint('sender_id != receiver_id', name='check_no_self_recognition'),
    )

class Endorsement(Base):
    __tablename__ = "endorsements"
    
    id = Column(Integer, primary_key=True, index=True)
    recognition_id = Column(Integer, ForeignKey("recognitions.id"), nullable=False)
    endorser_id = Column(Integer, ForeignKey("students.id"), nullable=False)
    created_at = Column(DateTime, default=datetime.now)
    
    # Relationships
    recognition = relationship("Recognition", back_populates="endorsements")
    
    __table_args__ = (
        CheckConstraint('endorser_id != (SELECT receiver_id FROM recognitions WHERE recognitions.id = recognition_id)', 
                       name='check_endorser_not_receiver'),  # Simplified constraint
    )

class Redemption(Base):
    __tablename__ = "redemptions"
    
    id = Column(Integer, primary_key=True, index=True)
    student_id = Column(Integer, ForeignKey("students.id"), nullable=False)
    credits_redeemed = Column(Integer, nullable=False)
    voucher_amount = Column(Integer, nullable=False)  # In rupees (credits * 5)
    created_at = Column(DateTime, default=datetime.now)
    
    # Relationships
    student = relationship("Student", back_populates="redemptions")
    
    __table_args__ = (
        CheckConstraint('credits_redeemed > 0', name='check_redemption_positive'),
    )

```


Creating Pydantic schemas and business logic utilities:


```python
from pydantic import BaseModel, EmailStr
from typing import Optional
from datetime import datetime

# Student Schemas
class StudentCreate(BaseModel):
    name: str
    email: EmailStr

class StudentResponse(BaseModel):
    id: int
    name: str
    email: str
    current_balance: int
    monthly_sending_limit: int
    
    class Config:
        from_attributes = True

# Recognition Schemas
class RecognitionCreate(BaseModel):
    receiver_id: int
    credits: int
    message: Optional[str] = None

class RecognitionResponse(BaseModel):
    id: int
    sender_id: int
    receiver_id: int
    credits: int
    message: Optional[str]
    created_at: datetime
    endorsement_count: int = 0
    
    class Config:
        from_attributes = True

# Endorsement Schemas
class EndorsementCreate(BaseModel):
    recognition_id: int

class EndorsementResponse(BaseModel):
    id: int
    recognition_id: int
    endorser_id: int
    created_at: datetime
    
    class Config:
        from_attributes = True

# Redemption Schemas
class RedemptionCreate(BaseModel):
    credits_redeemed: int

class RedemptionResponse(BaseModel):
    id: int
    student_id: int
    credits_redeemed: int
    voucher_amount: int
    created_at: datetime
    
    class Config:
        from_attributes = True

# Leaderboard Schemas
class LeaderboardEntry(BaseModel):
    student_id: int
    student_name: str
    total_credits_received: int
    total_recognitions_received: int
    total_endorsements_received: int

```

```python
from datetime import datetime
from sqlalchemy.orm import Session
from models import Student
from dateutil.relativedelta import relativedelta

def get_current_month_year() -> str:
    """Get current month-year string in YYYY-MM format"""
    return datetime.now().strftime("%Y-%m")

def should_reset_credits(student: Student) -> bool:
    """Check if student's credits should be reset based on last reset date"""
    current_date = datetime.now()
    last_reset = student.last_reset_date
    
    # Check if we're in a different month
    if current_date.year > last_reset.year or \
       (current_date.year == last_reset.year and current_date.month > last_reset.month):
        return True
    return False

def reset_student_credits(db: Session, student: Student):
    """Reset student credits with carry-forward logic"""
    # Calculate carry-forward (max 50 credits)
    unused_credits = student.current_balance
    carry_forward = min(unused_credits, 50)
    
    # Reset to 100 + carry_forward
    student.current_balance = 100 + carry_forward
    student.monthly_sending_limit = 100
    student.last_reset_date = datetime.now()
    
    db.commit()
    db.refresh(student)

def check_and_reset_all_credits(db: Session):
    """Check all students and reset credits if needed"""
    students = db.query(Student).all()
    for student in students:
        if should_reset_credits(student):
            reset_student_credits(db, student)

```


Creating the main FastAPI application with all endpoints:


```python
from fastapi import FastAPI, Depends, HTTPException, status
from sqlalchemy.orm import Session
from sqlalchemy import func, and_, or_
from datetime import datetime
from typing import List, Optional

from database import Base, engine, get_db
from models import Student, Recognition, Endorsement, Redemption
from schemas import (
    StudentCreate, StudentResponse,
    RecognitionCreate, RecognitionResponse,
    EndorsementCreate, EndorsementResponse,
    RedemptionCreate, RedemptionResponse,
    LeaderboardEntry
)
from utils import get_current_month_year, check_and_reset_all_credits, should_reset_credits, reset_student_credits

# Create database tables
Base.metadata.create_all(bind=engine)

app = FastAPI(title="Boostly API", description="Boost morale, one kudos at a time", version="1.0.0")

# Middleware to check and reset credits on each request
@app.middleware("http")
async def reset_credits_middleware(request, call_next):
    db = next(get_db())
    try:
        check_and_reset_all_credits(db)
    finally:
        db.close()
    response = await call_next(request)
    return response

# ==================== Student Endpoints ====================

@app.post("/students", response_model=StudentResponse, status_code=status.HTTP_201_CREATED)
def create_student(student: StudentCreate, db: Session = Depends(get_db)):
    """Create a new student"""
    # Check if email already exists
    existing_student = db.query(Student).filter(Student.email == student.email).first()
    if existing_student:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Student with this email already exists"
        )
    
    new_student = Student(
        name=student.name,
        email=student.email,
        current_balance=100,
        monthly_sending_limit=100,
        last_reset_date=datetime.now()
    )
    db.add(new_student)
    db.commit()
    db.refresh(new_student)
    return new_student

@app.get("/students/{student_id}", response_model=StudentResponse)
def get_student(student_id: int, db: Session = Depends(get_db)):
    """Get student by ID"""
    student = db.query(Student).filter(Student.id == student_id).first()
    if not student:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Student not found"
        )
    
    # Check and reset if needed
    if should_reset_credits(student):
        reset_student_credits(db, student)
    
    return student

@app.get("/students", response_model=List[StudentResponse])
def get_all_students(db: Session = Depends(get_db)):
    """Get all students"""
    students = db.query(Student).all()
    return students

# ==================== Recognition Endpoints ====================

@app.post("/recognitions", response_model=RecognitionResponse, status_code=status.HTTP_201_CREATED)
def create_recognition(
    sender_id: int,
    recognition: RecognitionCreate,
    db: Session = Depends(get_db)
):
    """Create a recognition (sender recognizes receiver with credits)"""
    # Validate sender
    sender = db.query(Student).filter(Student.id == sender_id).first()
    if not sender:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Sender not found"
        )
    
    # Check and reset sender credits if needed
    if should_reset_credits(sender):
        reset_student_credits(db, sender)
    
    # Validate receiver
    receiver = db.query(Student).filter(Student.id == recognition.receiver_id).first()
    if not receiver:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Receiver not found"
        )
    
    # Business Rules Validation
    # 1. Cannot send to self
    if sender_id == recognition.receiver_id:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Students cannot send credits to themselves"
        )
    
    # 2. Cannot send more than current balance
    if recognition.credits > sender.current_balance:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Insufficient balance. Current balance: {sender.current_balance}, requested: {recognition.credits}"
        )
    
    # 3. Check monthly sending limit
    current_month = get_current_month_year()
    monthly_sent = db.query(func.sum(Recognition.credits)).filter(
        and_(
            Recognition.sender_id == sender_id,
            Recognition.month_year == current_month
        )
    ).scalar() or 0
    
    if monthly_sent + recognition.credits > sender.monthly_sending_limit:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Monthly sending limit exceeded. Limit: {sender.monthly_sending_limit}, already sent: {monthly_sent}, requested: {recognition.credits}"
        )
    
    # Create recognition
    new_recognition = Recognition(
        sender_id=sender_id,
        receiver_id=recognition.receiver_id,
        credits=recognition.credits,
        message=recognition.message,
        month_year=current_month
    )
    db.add(new_recognition)
    
    # Update balances
    sender.current_balance -= recognition.credits
    receiver.current_balance += recognition.credits
    
    db.commit()
    db.refresh(new_recognition)
    
    # Get endorsement count
    endorsement_count = db.query(func.count(Endorsement.id)).filter(
        Endorsement.recognition_id == new_recognition.id
    ).scalar() or 0
    
    response = RecognitionResponse(
        id=new_recognition.id,
        sender_id=new_recognition.sender_id,
        receiver_id=new_recognition.receiver_id,
        credits=new_recognition.credits,
        message=new_recognition.message,
        created_at=new_recognition.created_at,
        endorsement_count=endorsement_count
    )
    
    return response

@app.get("/recognitions/{recognition_id}", response_model=RecognitionResponse)
def get_recognition(recognition_id: int, db: Session = Depends(get_db)):
    """Get recognition by ID"""
    recognition = db.query(Recognition).filter(Recognition.id == recognition_id).first()
    if not recognition:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Recognition not found"
        )
    
    endorsement_count = db.query(func.count(Endorsement.id)).filter(
        Endorsement.recognition_id == recognition_id
    ).scalar() or 0
    
    response = RecognitionResponse(
        id=recognition.id,
        sender_id=recognition.sender_id,
        receiver_id=recognition.receiver_id,
        credits=recognition.credits,
        message=recognition.message,
        created_at=recognition.created_at,
        endorsement_count=endorsement_count
    )
    
    return response

@app.get("/recognitions", response_model=List[RecognitionResponse])
def get_all_recognitions(db: Session = Depends(get_db)):
    """Get all recognitions"""
    recognitions = db.query(Recognition).all()
    result = []
    for rec in recognitions:
        endorsement_count = db.query(func.count(Endorsement.id)).filter(
            Endorsement.recognition_id == rec.id
        ).scalar() or 0
        result.append(RecognitionResponse(
            id=rec.id,
            sender_id=rec.sender_id,
            receiver_id=rec.receiver_id,
            credits=rec.credits,
            message=rec.message,
            created_at=rec.created_at,
            endorsement_count=endorsement_count
        ))
    return result

# ==================== Endorsement Endpoints ====================

@app.post("/endorsements", response_model=EndorsementResponse, status_code=status.HTTP_201_CREATED)
def create_endorsement(
    endorser_id: int,
    endorsement: EndorsementCreate,
    db: Session = Depends(get_db)
):
    """Create an endorsement (like/cheer for a recognition)"""
    # Validate endorser
    endorser = db.query(Student).filter(Student.id == endorser_id).first()
    if not endorser:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Endorser not found"
        )
    
    # Validate recognition
    recognition = db.query(Recognition).filter(Recognition.id == endorsement.recognition_id).first()
    if not recognition:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Recognition not found"
        )
    
    # Business Rule: Each endorser can endorse a recognition only once
    existing_endorsement = db.query(Endorsement).filter(
        and_(
            Endorsement.recognition_id == endorsement.recognition_id,
            Endorsement.endorser_id == endorser_id
        )
    ).first()
    
    if existing_endorsement:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="You have already endorsed this recognition"
        )
    
    # Create endorsement
    new_endorsement = Endorsement(
        recognition_id=endorsement.recognition_id,
        endorser_id=endorser_id
    )
    db.add(new_endorsement)
    db.commit()
    db.refresh(new_endorsement)
    
    return new_endorsement

@app.get("/endorsements/{endorsement_id}", response_model=EndorsementResponse)
def get_endorsement(endorsement_id: int, db: Session = Depends(get_db)):
    """Get endorsement by ID"""
    endorsement = db.query(Endorsement).filter(Endorsement.id == endorsement_id).first()
    if not endorsement:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Endorsement not found"
        )
    return endorsement

# ==================== Redemption Endpoints ====================

@app.post("/redemptions", response_model=RedemptionResponse, status_code=status.HTTP_201_CREATED)
def create_redemption(
    student_id: int,
    redemption: RedemptionCreate,
    db: Session = Depends(get_db)
):
    """Redeem credits for voucher (₹5 per credit)"""
    # Validate student
    student = db.query(Student).filter(Student.id == student_id).first()
    if not student:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Student not found"
        )
    
    # Check and reset if needed
    if should_reset_credits(student):
        reset_student_credits(db, student)
    
    # Business Rules Validation
    # 1. Cannot redeem more than current balance
    if redemption.credits_redeemed > student.current_balance:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Insufficient balance. Current balance: {student.current_balance}, requested: {redemption.credits_redeemed}"
        )
    
    # 2. Must redeem at least 1 credit
    if redemption.credits_redeemed <= 0:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Credits to redeem must be greater than 0"
        )
    
    # Calculate voucher amount (₹5 per credit)
    voucher_amount = redemption.credits_redeemed * 5
    
    # Create redemption
    new_redemption = Redemption(
        student_id=student_id,
        credits_redeemed=redemption.credits_redeemed,
        voucher_amount=voucher_amount
    )
    db.add(new_redemption)
    
    # Permanently deduct credits
    student.current_balance -= redemption.credits_redeemed
    
    db.commit()
    db.refresh(new_redemption)
    
    return new_redemption

@app.get("/redemptions/{redemption_id}", response_model=RedemptionResponse)
def get_redemption(redemption_id: int, db: Session = Depends(get_db)):
    """Get redemption by ID"""
    redemption = db.query(Redemption).filter(Redemption.id == redemption_id).first()
    if not redemption:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Redemption not found"
        )
    return redemption

@app.get("/students/{student_id}/redemptions", response_model=List[RedemptionResponse])
def get_student_redemptions(student_id: int, db: Session = Depends(get_db)):
    """Get all redemptions for a student"""
    student = db.query(Student).filter(Student.id == student_id).first()
    if not student:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Student not found"
        )
    
    redemptions = db.query(Redemption).filter(Redemption.student_id == student_id).all()
    return redemptions

# ==================== Leaderboard Endpoint ====================

@app.get("/leaderboard", response_model=List[LeaderboardEntry])
def get_leaderboard(limit: Optional[int] = 10, db: Session = Depends(get_db)):
    """Get leaderboard of top recipients ranked by total credits received"""
    # Query to get total credits received per student
    credits_query = db.query(
        Recognition.receiver_id,
        func.sum(Recognition.credits).label('total_credits')
    ).group_by(Recognition.receiver_id).subquery()
    
    # Query to get total recognitions received per student
    recognitions_query = db.query(
        Recognition.receiver_id,
        func.count(Recognition.id).label('total_recognitions')
    ).group_by(Recognition.receiver_id).subquery()
    
    # Query to get total endorsements received per student (across all their recognitions)
    endorsements_query = db.query(
        Recognition.receiver_id,
        func.count(Endorsement.id).label('total_endorsements')
    ).join(Endorsement, Recognition.id == Endorsement.recognition_id)\
     .group_by(Recognition.receiver_id).subquery()
    
    # Main query joining all data
    leaderboard = db.query(
        Student.id.label('student_id'),
        Student.name.label('student_name'),
        func.coalesce(credits_query.c.total_credits, 0).label('total_credits_received'),
        func.coalesce(recognitions_query.c.total_recognitions, 0).label('total_recognitions_received'),
        func.coalesce(endorsements_query.c.total_endorsements, 0).label('total_endorsements_received')
    ).outerjoin(credits_query, Student.id == credits_query.c.receiver_id)\
     .outerjoin(recognitions_query, Student.id == recognitions_query.c.receiver_id)\
     .outerjoin(endorsements_query, Student.id == endorsements_query.c.receiver_id)\
     .filter(func.coalesce(credits_query.c.total_credits, 0) > 0)\
     .order_by(
         func.coalesce(credits_query.c.total_credits, 0).desc(),
         Student.id.asc()
     ).limit(limit).all()
    
    result = []
    for entry in leaderboard:
        result.append(LeaderboardEntry(
            student_id=entry.student_id,
            student_name=entry.student_name,
            total_credits_received=int(entry.total_credits_received),
            total_recognitions_received=int(entry.total_recognitions_received),
            total_endorsements_received=int(entry.total_endorsements_received)
        ))
    
    return result

# ==================== Credit Reset Endpoint (Manual) ====================

@app.post("/credits/reset", status_code=status.HTTP_200_OK)
def manual_reset_credits(db: Session = Depends(get_db)):
    """Manually trigger credit reset for all students (useful for testing)"""
    check_and_reset_all_credits(db)
    return {"message": "Credits reset completed for all eligible students"}

# ==================== Health Check ====================

@app.get("/")
def root():
    """Health check endpoint"""
    return {"message": "Boostly API is running", "version": "1.0.0"}

```


Checking for linting errors and fixing them:



Creating the README with setup instructions and API documentation:


```markdown
# Boostly API - Project Documentation

## Overview

Boostly is a platform that enables college students to recognize their peers, allocate monthly credits, and redeem earned rewards. The application encourages appreciation and engagement across student communities.

## Technology Stack

- **Framework**: FastAPI (Python)
- **Database**: SQLite (can be easily switched to PostgreSQL/MySQL)
- **ORM**: SQLAlchemy
- **Validation**: Pydantic

## Setup Instructions

### Prerequisites

- Python 3.8 or higher
- pip (Python package manager)

### Installation Steps

1. **Navigate to the src directory**:
   ```bash
   cd src
   ```

2. **Create a virtual environment** (recommended):
   ```bash
   python3 -m venv venv
   source venv/bin/activate  # On Windows: venv\Scripts\activate
   ```

3. **Install dependencies**:
   ```bash
   pip install -r requirements.txt
   ```

4. **Run the application**:
   ```bash
   uvicorn main:app --reload
   ```

   The API will be available at: `http://localhost:8000`

5. **Access API documentation**:
   - Swagger UI: `http://localhost:8000/docs`
   - ReDoc: `http://localhost:8000/redoc`

## Database

The application uses SQLite by default. The database file (`boostly.db`) will be automatically created in the `src/` directory when you first run the application.

### Database Schema

- **students**: Stores student information and credit balances
- **recognitions**: Stores recognition transactions between students
- **endorsements**: Stores endorsements (likes) on recognitions
- **redemptions**: Stores credit redemption transactions

## API Endpoints

### Health Check

#### GET `/`
Check if the API is running.

**Response**:
```json
{
  "message": "Boostly API is running",
  "version": "1.0.0"
}
```

---

### Student Endpoints

#### POST `/students`
Create a new student.

**Request Body**:
```json
{
  "name": "John Doe",
  "email": "john.doe@example.com"
}
```

**Response** (201 Created):
```json
{
  "id": 1,
  "name": "John Doe",
  "email": "john.doe@example.com",
  "current_balance": 100,
  "monthly_sending_limit": 100
}
```

#### GET `/students/{student_id}`
Get student by ID.

**Response** (200 OK):
```json
{
  "id": 1,
  "name": "John Doe",
  "email": "john.doe@example.com",
  "current_balance": 100,
  "monthly_sending_limit": 100
}
```

#### GET `/students`
Get all students.

**Response** (200 OK):
```json
[
  {
    "id": 1,
    "name": "John Doe",
    "email": "john.doe@example.com",
    "current_balance": 100,
    "monthly_sending_limit": 100
  }
]
```

---

### Recognition Endpoints

#### POST `/recognitions?sender_id={sender_id}`
Create a recognition (transfer credits from sender to receiver).

**Query Parameters**:
- `sender_id` (required): ID of the student sending credits

**Request Body**:
```json
{
  "receiver_id": 2,
  "credits": 20,
  "message": "Great work on the project!"
}
```

**Response** (201 Created):
```json
{
  "id": 1,
  "sender_id": 1,
  "receiver_id": 2,
  "credits": 20,
  "message": "Great work on the project!",
  "created_at": "2024-01-15T10:30:00",
  "endorsement_count": 0
}
```

**Business Rules**:
- Students cannot send credits to themselves
- Cannot send more credits than current balance
- Cannot exceed monthly sending limit (100 credits per month)
- Each student receives 100 credits every month (resets at start of calendar month)

#### GET `/recognitions/{recognition_id}`
Get recognition by ID.

**Response** (200 OK):
```json
{
  "id": 1,
  "sender_id": 1,
  "receiver_id": 2,
  "credits": 20,
  "message": "Great work on the project!",
  "created_at": "2024-01-15T10:30:00",
  "endorsement_count": 3
}
```

#### GET `/recognitions`
Get all recognitions.

**Response** (200 OK):
```json
[
  {
    "id": 1,
    "sender_id": 1,
    "receiver_id": 2,
    "credits": 20,
    "message": "Great work on the project!",
    "created_at": "2024-01-15T10:30:00",
    "endorsement_count": 3
  }
]
```

---

### Endorsement Endpoints

#### POST `/endorsements?endorser_id={endorser_id}`
Create an endorsement (like/cheer for a recognition).

**Query Parameters**:
- `endorser_id` (required): ID of the student endorsing

**Request Body**:
```json
{
  "recognition_id": 1
}
```

**Response** (201 Created):
```json
{
  "id": 1,
  "recognition_id": 1,
  "endorser_id": 3,
  "created_at": "2024-01-15T11:00:00"
}
```

**Business Rules**:
- Each endorser can endorse a recognition only once
- Endorsements don't affect credit balances

#### GET `/endorsements/{endorsement_id}`
Get endorsement by ID.

**Response** (200 OK):
```json
{
  "id": 1,
  "recognition_id": 1,
  "endorser_id": 3,
  "created_at": "2024-01-15T11:00:00"
}
```

---

### Redemption Endpoints

#### POST `/redemptions?student_id={student_id}`
Redeem credits for voucher (₹5 per credit).

**Query Parameters**:
- `student_id` (required): ID of the student redeeming

**Request Body**:
```json
{
  "credits_redeemed": 50
}
```

**Response** (201 Created):
```json
{
  "id": 1,
  "student_id": 2,
  "credits_redeemed": 50,
  "voucher_amount": 250,
  "created_at": "2024-01-15T12:00:00"
}
```

**Business Rules**:
- Credits are converted at ₹5 per credit
- Credits are permanently deducted from balance
- Can only redeem credits that have been received

#### GET `/redemptions/{redemption_id}`
Get redemption by ID.

**Response** (200 OK):
```json
{
  "id": 1,
  "student_id": 2,
  "credits_redeemed": 50,
  "voucher_amount": 250,
  "created_at": "2024-01-15T12:00:00"
}
```

#### GET `/students/{student_id}/redemptions`
Get all redemptions for a student.

**Response** (200 OK):
```json
[
  {
    "id": 1,
    "student_id": 2,
    "credits_redeemed": 50,
    "voucher_amount": 250,
    "created_at": "2024-01-15T12:00:00"
  }
]
```

---

### Leaderboard Endpoint

#### GET `/leaderboard?limit={limit}`
Get leaderboard of top recipients ranked by total credits received.

**Query Parameters**:
- `limit` (optional): Number of top students to return (default: 10)

**Response** (200 OK):
```json
[
  {
    "student_id": 2,
    "student_name": "Jane Smith",
    "total_credits_received": 150,
    "total_recognitions_received": 5,
    "total_endorsements_received": 12
  },
  {
    "student_id": 3,
    "student_name": "Bob Johnson",
    "total_credits_received": 120,
    "total_recognitions_received": 4,
    "total_endorsements_received": 8
  }
]
```

**Business Rules**:
- Ranked by total credits received (descending)
- If same credits, ranked by student ID (ascending)
- Includes total recognitions and endorsements received

---

### Credit Reset Endpoint

#### POST `/credits/reset`
Manually trigger credit reset for all students (useful for testing).

**Response** (200 OK):
```json
{
  "message": "Credits reset completed for all eligible students"
}
```

**Note**: Credits are automatically reset at the start of each calendar month. This endpoint is for manual testing.

---

## Sample Requests (cURL)

### Create a Student
```bash
curl -X POST "http://localhost:8000/students" \
  -H "Content-Type: application/json" \
  -d '{
    "name": "John Doe",
    "email": "john.doe@example.com"
  }'
```

### Create a Recognition
```bash
curl -X POST "http://localhost:8000/recognitions?sender_id=1" \
  -H "Content-Type: application/json" \
  -d '{
    "receiver_id": 2,
    "credits": 20,
    "message": "Great work!"
  }'
```

### Create an Endorsement
```bash
curl -X POST "http://localhost:8000/endorsements?endorser_id=3" \
  -H "Content-Type: application/json" \
  -d '{
    "recognition_id": 1
  }'
```

### Redeem Credits
```bash
curl -X POST "http://localhost:8000/redemptions?student_id=2" \
  -H "Content-Type: application/json" \
  -d '{
    "credits_redeemed": 50
  }'
```

### Get Leaderboard
```bash
curl -X GET "http://localhost:8000/leaderboard?limit=5"
```

---

## Credit Reset Mechanism

The application automatically resets credits at the start of each calendar month:

- Each student's available credits reset to **100** at the start of each calendar month
- Up to **50 unused credits** from the previous month can be carried forward
- If a student has more than 50 unused credits, only 50 can be carried forward
- The monthly sending limit also resets to **100 credits**

The reset is checked automatically on each API request via middleware. If a student's last reset date is in a previous month, their credits are automatically reset.

---

## Error Responses

All endpoints return appropriate HTTP status codes:

- **200 OK**: Successful GET request
- **201 Created**: Successful POST request (resource created)
- **400 Bad Request**: Validation error or business rule violation
- **404 Not Found**: Resource not found

**Example Error Response**:
```json
{
  "detail": "Insufficient balance. Current balance: 50, requested: 100"
}
```

---

## Project Structure

```
src/
├── main.py              # FastAPI application and endpoints
├── models.py            # SQLAlchemy database models
├── schemas.py           # Pydantic request/response schemas
├── database.py          # Database configuration
├── utils.py             # Utility functions (credit reset logic)
├── requirements.txt     # Python dependencies
└── readme.md           # This file
```

---

## Notes

- The database file (`boostly.db`) is created automatically in the `src/` directory
- All timestamps are in UTC
- Credit reset happens automatically via middleware on each request
- Monthly limits are tracked using `YYYY-MM` format

```


Creating test cases documentation:


```plaintext
# Boostly API - Test Cases Documentation

This document provides detailed instructions on how to test each feature of the Boostly application.

## Prerequisites

1. Ensure the application is running:
   ```bash
   cd src
   uvicorn main:app --reload
   ```

2. The API should be accessible at `http://localhost:8000`

3. You can use cURL, Postman, or the Swagger UI at `http://localhost:8000/docs` for testing

---

## Test Case 1: Student Management

### 1.1 Create Students

**Purpose**: Test creating new students with initial credit balance of 100.

**Steps**:
1. Create Student 1:
   ```bash
   curl -X POST "http://localhost:8000/students" \
     -H "Content-Type: application/json" \
     -d '{"name": "Alice", "email": "alice@example.com"}'
   ```
   **Expected Result**: Student created with `id: 1`, `current_balance: 100`, `monthly_sending_limit: 100`

2. Create Student 2:
   ```bash
   curl -X POST "http://localhost:8000/students" \
     -H "Content-Type: application/json" \
     -d '{"name": "Bob", "email": "bob@example.com"}'
   ```
   **Expected Result**: Student created with `id: 2`, `current_balance: 100`, `monthly_sending_limit: 100`

3. Create Student 3:
   ```bash
   curl -X POST "http://localhost:8000/students" \
     -H "Content-Type: application/json" \
     -d '{"name": "Charlie", "email": "charlie@example.com"}'
   ```
   **Expected Result**: Student created with `id: 3`, `current_balance: 100`, `monthly_sending_limit: 100`

4. Try to create duplicate email:
   ```bash
   curl -X POST "http://localhost:8000/students" \
     -H "Content-Type: application/json" \
     -d '{"name": "Alice Duplicate", "email": "alice@example.com"}'
   ```
   **Expected Result**: Error 400 - "Student with this email already exists"

### 1.2 Get Student Information

**Steps**:
```bash
curl -X GET "http://localhost:8000/students/1"
```

**Expected Result**: Returns student details with current balance and sending limit

---

## Test Case 2: Recognition Feature

### 2.1 Basic Recognition (Send Credits)

**Purpose**: Test sending credits from one student to another.

**Steps**:
1. Alice sends 20 credits to Bob:
   ```bash
   curl -X POST "http://localhost:8000/recognitions?sender_id=1" \
     -H "Content-Type: application/json" \
     -d '{"receiver_id": 2, "credits": 20, "message": "Great work on the project!"}'
   ```
   **Expected Result**: 
   - Recognition created successfully
   - Alice's balance: 80 (100 - 20)
   - Bob's balance: 120 (100 + 20)

2. Verify balances:
   ```bash
   curl -X GET "http://localhost:8000/students/1"
   curl -X GET "http://localhost:8000/students/2"
   ```

### 2.2 Self-Recognition Prevention

**Purpose**: Test that students cannot send credits to themselves.

**Steps**:
```bash
curl -X POST "http://localhost:8000/recognitions?sender_id=1" \
  -H "Content-Type: application/json" \
  -d '{"receiver_id": 1, "credits": 10, "message": "Self recognition"}'
```

**Expected Result**: Error 400 - "Students cannot send credits to themselves"

### 2.3 Insufficient Balance Check

**Purpose**: Test that students cannot send more credits than they have.

**Steps**:
1. Alice (balance: 80) tries to send 100 credits:
   ```bash
   curl -X POST "http://localhost:8000/recognitions?sender_id=1" \
     -H "Content-Type: application/json" \
     -d '{"receiver_id": 2, "credits": 100, "message": "Too many credits"}'
   ```
   **Expected Result**: Error 400 - "Insufficient balance. Current balance: 80, requested: 100"

### 2.4 Monthly Sending Limit

**Purpose**: Test that students cannot exceed monthly sending limit of 100 credits.

**Steps**:
1. Alice sends 50 credits to Bob:
   ```bash
   curl -X POST "http://localhost:8000/recognitions?sender_id=1" \
     -H "Content-Type: application/json" \
     -d '{"receiver_id": 2, "credits": 50, "message": "First batch"}'
   ```
   **Expected Result**: Success (Alice's balance: 30, monthly sent: 70)

2. Alice tries to send 50 more credits:
   ```bash
   curl -X POST "http://localhost:8000/recognitions?sender_id=1" \
     -H "Content-Type: application/json" \
     -d '{"receiver_id": 3, "credits": 50, "message": "Second batch"}'
   ```
   **Expected Result**: Error 400 - "Monthly sending limit exceeded. Limit: 100, already sent: 70, requested: 50"

### 2.5 Get Recognition

**Steps**:
```bash
curl -X GET "http://localhost:8000/recognitions/1"
```

**Expected Result**: Returns recognition details with endorsement count

### 2.6 Get All Recognitions

**Steps**:
```bash
curl -X GET "http://localhost:8000/recognitions"
```

**Expected Result**: Returns list of all recognitions

---

## Test Case 3: Endorsements Feature

### 3.1 Create Endorsement

**Purpose**: Test endorsing (liking) a recognition.

**Steps**:
1. Charlie endorses Alice's recognition to Bob:
   ```bash
   curl -X POST "http://localhost:8000/endorsements?endorser_id=3" \
     -H "Content-Type: application/json" \
     -d '{"recognition_id": 1}'
   ```
   **Expected Result**: Endorsement created successfully

2. Verify endorsement count:
   ```bash
   curl -X GET "http://localhost:8000/recognitions/1"
   ```
   **Expected Result**: `endorsement_count: 1`

### 3.2 Duplicate Endorsement Prevention

**Purpose**: Test that each endorser can only endorse a recognition once.

**Steps**:
1. Charlie tries to endorse the same recognition again:
   ```bash
   curl -X POST "http://localhost:8000/endorsements?endorser_id=3" \
     -H "Content-Type: application/json" \
     -d '{"recognition_id": 1}'
   ```
   **Expected Result**: Error 400 - "You have already endorsed this recognition"

2. Bob can still endorse (different endorser):
   ```bash
   curl -X POST "http://localhost:8000/endorsements?endorser_id=2" \
     -H "Content-Type: application/json" \
     -d '{"recognition_id": 1}'
   ```
   **Expected Result**: Success (endorsement_count should be 2)

### 3.3 Multiple Endorsements

**Purpose**: Test that multiple students can endorse the same recognition.

**Steps**:
1. Create multiple recognitions
2. Have different students endorse them
3. Check endorsement counts

**Expected Result**: Each recognition shows correct endorsement count

---

## Test Case 4: Redemption Feature

### 4.1 Basic Redemption

**Purpose**: Test redeeming credits for vouchers (₹5 per credit).

**Steps**:
1. Bob (balance: 120) redeems 50 credits:
   ```bash
   curl -X POST "http://localhost:8000/redemptions?student_id=2" \
     -H "Content-Type: application/json" \
     -d '{"credits_redeemed": 50}'
   ```
   **Expected Result**: 
   - Redemption created successfully
   - `voucher_amount: 250` (50 * 5)
   - Bob's balance: 70 (120 - 50)

2. Verify Bob's balance:
   ```bash
   curl -X GET "http://localhost:8000/students/2"
   ```
   **Expected Result**: `current_balance: 70`

### 4.2 Insufficient Balance for Redemption

**Purpose**: Test that students cannot redeem more credits than they have.

**Steps**:
1. Bob (balance: 70) tries to redeem 100 credits:
   ```bash
   curl -X POST "http://localhost:8000/redemptions?student_id=2" \
     -H "Content-Type: application/json" \
     -d '{"credits_redeemed": 100}'
   ```
   **Expected Result**: Error 400 - "Insufficient balance. Current balance: 70, requested: 100"

### 4.3 Multiple Redemptions

**Purpose**: Test that students can make multiple redemptions.

**Steps**:
1. Bob redeems 20 more credits:
   ```bash
   curl -X POST "http://localhost:8000/redemptions?student_id=2" \
     -H "Content-Type: application/json" \
     -d '{"credits_redeemed": 20}'
   ```
   **Expected Result**: Success, voucher_amount: 100, balance: 50

2. Get all redemptions for Bob:
   ```bash
   curl -X GET "http://localhost:8000/students/2/redemptions"
   ```
   **Expected Result**: Returns list of all redemptions made by Bob

### 4.4 Verify Credits are Permanently Deducted

**Purpose**: Test that redeemed credits are permanently removed from balance.

**Steps**:
1. Note Bob's balance before redemption
2. Make a redemption
3. Check balance after redemption
4. Verify balance decreased by exact redemption amount

**Expected Result**: Credits are permanently deducted and cannot be recovered

---

## Test Case 5: Credit Reset Mechanism (Step-Up Challenge)

### 5.1 Automatic Monthly Reset

**Purpose**: Test automatic credit reset at the start of a new month.

**Steps**:
1. Set up a student with some balance (e.g., 30 credits remaining)
2. Manually trigger reset (for testing):
   ```bash
   curl -X POST "http://localhost:8000/credits/reset"
   ```
   **Expected Result**: Credits reset to 100 (or 100 + carry-forward if applicable)

**Note**: In production, reset happens automatically when month changes.

### 5.2 Carry-Forward Mechanism

**Purpose**: Test that up to 50 unused credits can be carried forward.

**Steps**:
1. Create a student and ensure they have 30 credits remaining
2. Trigger credit reset
3. Check new balance

**Expected Result**: 
- If student had 30 credits: New balance = 100 + 30 = 130
- If student had 60 credits: New balance = 100 + 50 = 150 (max carry-forward is 50)
- If student had 10 credits: New balance = 100 + 10 = 110

### 5.3 Monthly Sending Limit Reset

**Purpose**: Test that monthly sending limit resets with credits.

**Steps**:
1. Use up monthly sending limit (send 100 credits)
2. Trigger credit reset
3. Try to send credits again

**Expected Result**: Monthly sending limit resets to 100, student can send again

---

## Test Case 6: Leaderboard Feature (Step-Up Challenge)

### 6.1 Basic Leaderboard

**Purpose**: Test leaderboard ranking by total credits received.

**Steps**:
1. Create multiple recognitions:
   - Alice sends 30 credits to Bob
   - Charlie sends 50 credits to Bob
   - Alice sends 20 credits to Charlie
   - Bob sends 10 credits to Charlie

2. Get leaderboard:
   ```bash
   curl -X GET "http://localhost:8000/leaderboard?limit=5"
   ```

**Expected Result**: 
- Bob ranked #1 (received 80 credits: 30 + 50)
- Charlie ranked #2 (received 30 credits: 20 + 10)
- Includes total recognitions and endorsements received

### 6.2 Tie-Breaking by Student ID

**Purpose**: Test that students with same credits are ranked by ID (ascending).

**Steps**:
1. Ensure two students have the same total credits received
2. Get leaderboard

**Expected Result**: Student with lower ID appears first

### 6.3 Leaderboard with Endorsements

**Purpose**: Test that leaderboard includes endorsement counts.

**Steps**:
1. Create recognitions
2. Add endorsements to recognitions
3. Get leaderboard

**Expected Result**: Leaderboard shows total endorsements received across all recognitions

### 6.4 Leaderboard Limit Parameter

**Purpose**: Test that limit parameter controls number of results.

**Steps**:
1. Get leaderboard with limit=3:
   ```bash
   curl -X GET "http://localhost:8000/leaderboard?limit=3"
   ```
2. Get leaderboard with limit=10:
   ```bash
   curl -X GET "http://localhost:8000/leaderboard?limit=10"
   ```

**Expected Result**: Returns exactly the specified number of top students

---

## Test Case 7: Complete Workflow

**Purpose**: Test a complete end-to-end workflow.

**Steps**:
1. **Setup**: Create 3 students (Alice, Bob, Charlie)

2. **Recognition**: 
   - Alice sends 30 credits to Bob with message "Great work!"
   - Bob sends 20 credits to Charlie with message "Well done!"

3. **Endorsements**:
   - Charlie endorses Alice's recognition to Bob
   - Alice endorses Bob's recognition to Charlie

4. **Redemption**:
   - Bob redeems 25 credits (should get ₹125 voucher)
   - Charlie redeems 10 credits (should get ₹50 voucher)

5. **Leaderboard**:
   - Check leaderboard to see rankings

6. **Verification**:
   - Check all balances
   - Check all recognitions
   - Check all redemptions

**Expected Result**: All operations complete successfully, balances are correct, leaderboard reflects accurate data

---

## Test Case 8: Edge Cases

### 8.1 Zero Credits

**Purpose**: Test behavior when student has 0 credits.

**Steps**:
1. Create student and use all credits
2. Try to send more credits
3. Try to redeem credits

**Expected Result**: Appropriate error messages for insufficient balance

### 8.2 Maximum Monthly Limit

**Purpose**: Test sending exactly 100 credits in a month.

**Steps**:
1. Send multiple recognitions totaling exactly 100 credits
2. Try to send one more credit

**Expected Result**: First 100 credits succeed, next credit fails with limit error

### 8.3 Invalid IDs

**Purpose**: Test error handling for non-existent resources.

**Steps**:
1. Try to get student with invalid ID
2. Try to create recognition with invalid sender/receiver ID
3. Try to create endorsement with invalid recognition ID

**Expected Result**: All return 404 Not Found errors

---

## Testing Tips

1. **Use Swagger UI**: Visit `http://localhost:8000/docs` for interactive API testing
2. **Check Database**: You can inspect `src/boostly.db` using SQLite tools
3. **Reset Database**: Delete `src/boostly.db` to start fresh
4. **Test Credit Reset**: Use `/credits/reset` endpoint to manually test reset logic
5. **Verify Balances**: Always check student balances after operations to ensure correctness

---

## Expected Test Results Summary

After running all test cases, you should verify:

✅ Students can be created with initial 100 credits
✅ Students can send credits to others (not themselves)
✅ Monthly sending limit of 100 credits is enforced
✅ Students cannot send more than their balance
✅ Endorsements can be created (one per endorser per recognition)
✅ Credits can be redeemed at ₹5 per credit
✅ Redeemed credits are permanently deducted
✅ Credits reset monthly with carry-forward (max 50)
✅ Leaderboard ranks students by credits received
✅ All error cases return appropriate HTTP status codes

```


Fixing a potential issue in the models and verifying the code:



Removing the problematic constraint; validation is handled in application logic:


```python
from sqlalchemy import Column, Integer, String, DateTime, ForeignKey, CheckConstraint
from sqlalchemy.orm import relationship
from datetime import datetime
from database import Base

class Student(Base):
    __tablename__ = "students"
    
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String, nullable=False)
    email = Column(String, unique=True, index=True, nullable=False)
    current_balance = Column(Integer, default=100, nullable=False)
    monthly_sending_limit = Column(Integer, default=100, nullable=False)
    last_reset_date = Column(DateTime, default=datetime.now)
    
    # Relationships
    sent_recognitions = relationship("Recognition", foreign_keys="Recognition.sender_id", back_populates="sender")
    received_recognitions = relationship("Recognition", foreign_keys="Recognition.receiver_id", back_populates="receiver")
    redemptions = relationship("Redemption", back_populates="student")
    
    __table_args__ = (
        CheckConstraint('current_balance >= 0', name='check_balance_non_negative'),
        CheckConstraint('monthly_sending_limit >= 0', name='check_sending_limit_non_negative'),
    )

class Recognition(Base):
    __tablename__ = "recognitions"
    
    id = Column(Integer, primary_key=True, index=True)
    sender_id = Column(Integer, ForeignKey("students.id"), nullable=False)
    receiver_id = Column(Integer, ForeignKey("students.id"), nullable=False)
    credits = Column(Integer, nullable=False)
    message = Column(String, nullable=True)
    created_at = Column(DateTime, default=datetime.now)
    month_year = Column(String, nullable=False)  # Format: "YYYY-MM" for tracking monthly limits
    
    # Relationships
    sender = relationship("Student", foreign_keys=[sender_id], back_populates="sent_recognitions")
    receiver = relationship("Student", foreign_keys=[receiver_id], back_populates="received_recognitions")
    endorsements = relationship("Endorsement", back_populates="recognition", cascade="all, delete-orphan")
    
    __table_args__ = (
        CheckConstraint('credits > 0', name='check_credits_positive'),
        CheckConstraint('sender_id != receiver_id', name='check_no_self_recognition'),
    )

class Endorsement(Base):
    __tablename__ = "endorsements"
    
    id = Column(Integer, primary_key=True, index=True)
    recognition_id = Column(Integer, ForeignKey("recognitions.id"), nullable=False)
    endorser_id = Column(Integer, ForeignKey("students.id"), nullable=False)
    created_at = Column(DateTime, default=datetime.now)
    
    # Relationships
    recognition = relationship("Recognition", back_populates="endorsements")

class Redemption(Base):
    __tablename__ = "redemptions"
    
    id = Column(Integer, primary_key=True, index=True)
    student_id = Column(Integer, ForeignKey("students.id"), nullable=False)
    credits_redeemed = Column(Integer, nullable=False)
    voucher_amount = Column(Integer, nullable=False)  # In rupees (credits * 5)
    created_at = Column(DateTime, default=datetime.now)
    
    # Relationships
    student = relationship("Student", back_populates="redemptions")
    
    __table_args__ = (
        CheckConstraint('credits_redeemed > 0', name='check_redemption_positive'),
    )


```


Adding a unique constraint to prevent duplicate endorsements:


```python
from sqlalchemy import Column, Integer, String, DateTime, ForeignKey, CheckConstraint, UniqueConstraint
from sqlalchemy.orm import relationship
from datetime import datetime
from database import Base

class Student(Base):
    __tablename__ = "students"
    
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String, nullable=False)
    email = Column(String, unique=True, index=True, nullable=False)
    current_balance = Column(Integer, default=100, nullable=False)
    monthly_sending_limit = Column(Integer, default=100, nullable=False)
    last_reset_date = Column(DateTime, default=datetime.now)
    
    # Relationships
    sent_recognitions = relationship("Recognition", foreign_keys="Recognition.sender_id", back_populates="sender")
    received_recognitions = relationship("Recognition", foreign_keys="Recognition.receiver_id", back_populates="receiver")
    redemptions = relationship("Redemption", back_populates="student")
    
    __table_args__ = (
        CheckConstraint('current_balance >= 0', name='check_balance_non_negative'),
        CheckConstraint('monthly_sending_limit >= 0', name='check_sending_limit_non_negative'),
    )

class Recognition(Base):
    __tablename__ = "recognitions"
    
    id = Column(Integer, primary_key=True, index=True)
    sender_id = Column(Integer, ForeignKey("students.id"), nullable=False)
    receiver_id = Column(Integer, ForeignKey("students.id"), nullable=False)
    credits = Column(Integer, nullable=False)
    message = Column(String, nullable=True)
    created_at = Column(DateTime, default=datetime.now)
    month_year = Column(String, nullable=False)  # Format: "YYYY-MM" for tracking monthly limits
    
    # Relationships
    sender = relationship("Student", foreign_keys=[sender_id], back_populates="sent_recognitions")
    receiver = relationship("Student", foreign_keys=[receiver_id], back_populates="received_recognitions")
    endorsements = relationship("Endorsement", back_populates="recognition", cascade="all, delete-orphan")
    
    __table_args__ = (
        CheckConstraint('credits > 0', name='check_credits_positive'),
        CheckConstraint('sender_id != receiver_id', name='check_no_self_recognition'),
    )

class Endorsement(Base):
    __tablename__ = "endorsements"
    
    id = Column(Integer, primary_key=True, index=True)
    recognition_id = Column(Integer, ForeignKey("recognitions.id"), nullable=False)
    endorser_id = Column(Integer, ForeignKey("students.id"), nullable=False)
    created_at = Column(DateTime, default=datetime.now)
    
    # Relationships
    recognition = relationship("Recognition", back_populates="endorsements")

class Redemption(Base):
    __tablename__ = "redemptions"
    
    id = Column(Integer, primary_key=True, index=True)
    student_id = Column(Integer, ForeignKey("students.id"), nullable=False)
    credits_redeemed = Column(Integer, nullable=False)
    voucher_amount = Column(Integer, nullable=False)  # In rupees (credits * 5)
    created_at = Column(DateTime, default=datetime.now)
    
    # Relationships
    student = relationship("Student", back_populates="redemptions")
    
    __table_args__ = (
        CheckConstraint('credits_redeemed > 0', name='check_redemption_positive'),
    )


```

```python
from sqlalchemy import Column, Integer, String, DateTime, ForeignKey, CheckConstraint, UniqueConstraint
from sqlalchemy.orm import relationship
from datetime import datetime
from database import Base

class Student(Base):
    __tablename__ = "students"
    
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String, nullable=False)
    email = Column(String, unique=True, index=True, nullable=False)
    current_balance = Column(Integer, default=100, nullable=False)
    monthly_sending_limit = Column(Integer, default=100, nullable=False)
    last_reset_date = Column(DateTime, default=datetime.now)
    
    # Relationships
    sent_recognitions = relationship("Recognition", foreign_keys="Recognition.sender_id", back_populates="sender")
    received_recognitions = relationship("Recognition", foreign_keys="Recognition.receiver_id", back_populates="receiver")
    redemptions = relationship("Redemption", back_populates="student")
    
    __table_args__ = (
        CheckConstraint('current_balance >= 0', name='check_balance_non_negative'),
        CheckConstraint('monthly_sending_limit >= 0', name='check_sending_limit_non_negative'),
    )

class Recognition(Base):
    __tablename__ = "recognitions"
    
    id = Column(Integer, primary_key=True, index=True)
    sender_id = Column(Integer, ForeignKey("students.id"), nullable=False)
    receiver_id = Column(Integer, ForeignKey("students.id"), nullable=False)
    credits = Column(Integer, nullable=False)
    message = Column(String, nullable=True)
    created_at = Column(DateTime, default=datetime.now)
    month_year = Column(String, nullable=False)  # Format: "YYYY-MM" for tracking monthly limits
    
    # Relationships
    sender = relationship("Student", foreign_keys=[sender_id], back_populates="sent_recognitions")
    receiver = relationship("Student", foreign_keys=[receiver_id], back_populates="received_recognitions")
    endorsements = relationship("Endorsement", back_populates="recognition", cascade="all, delete-orphan")
    
    __table_args__ = (
        CheckConstraint('credits > 0', name='check_credits_positive'),
        CheckConstraint('sender_id != receiver_id', name='check_no_self_recognition'),
    )

class Endorsement(Base):
    __tablename__ = "endorsements"
    
    id = Column(Integer, primary_key=True, index=True)
    recognition_id = Column(Integer, ForeignKey("recognitions.id"), nullable=False)
    endorser_id = Column(Integer, ForeignKey("students.id"), nullable=False)
    created_at = Column(DateTime, default=datetime.now)
    
    # Relationships
    recognition = relationship("Recognition", back_populates="endorsements")
    
    __table_args__ = (
        UniqueConstraint('recognition_id', 'endorser_id', name='unique_endorsement'),
    )

class Redemption(Base):
    __tablename__ = "redemptions"
    
    id = Column(Integer, primary_key=True, index=True)
    student_id = Column(Integer, ForeignKey("students.id"), nullable=False)
    credits_redeemed = Column(Integer, nullable=False)
    voucher_amount = Column(Integer, nullable=False)  # In rupees (credits * 5)
    created_at = Column(DateTime, default=datetime.now)
    
    # Relationships
    student = relationship("Student", back_populates="redemptions")
    
    __table_args__ = (
        CheckConstraint('credits_redeemed > 0', name='check_redemption_positive'),
    )


```


Verifying the project structure and creating a quick start guide:



Reviewing the leaderboard query for correctness:



Refactoring the leaderboard query for clarity and correctness:


```python
from fastapi import FastAPI, Depends, HTTPException, status
from sqlalchemy.orm import Session
from sqlalchemy import func, and_, or_
from datetime import datetime
from typing import List, Optional

from database import Base, engine, get_db
from models import Student, Recognition, Endorsement, Redemption
from schemas import (
    StudentCreate, StudentResponse,
    RecognitionCreate, RecognitionResponse,
    EndorsementCreate, EndorsementResponse,
    RedemptionCreate, RedemptionResponse,
    LeaderboardEntry
)
from utils import get_current_month_year, check_and_reset_all_credits, should_reset_credits, reset_student_credits

# Create database tables
Base.metadata.create_all(bind=engine)

app = FastAPI(title="Boostly API", description="Boost morale, one kudos at a time", version="1.0.0")

# Middleware to check and reset credits on each request
@app.middleware("http")
async def reset_credits_middleware(request, call_next):
    db = next(get_db())
    try:
        check_and_reset_all_credits(db)
    finally:
        db.close()
    response = await call_next(request)
    return response

# ==================== Student Endpoints ====================

@app.post("/students", response_model=StudentResponse, status_code=status.HTTP_201_CREATED)
def create_student(student: StudentCreate, db: Session = Depends(get_db)):
    """Create a new student"""
    # Check if email already exists
    existing_student = db.query(Student).filter(Student.email == student.email).first()
    if existing_student:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Student with this email already exists"
        )
    
    new_student = Student(
        name=student.name,
        email=student.email,
        current_balance=100,
        monthly_sending_limit=100,
        last_reset_date=datetime.now()
    )
    db.add(new_student)
    db.commit()
    db.refresh(new_student)
    return new_student

@app.get("/students/{student_id}", response_model=StudentResponse)
def get_student(student_id: int, db: Session = Depends(get_db)):
    """Get student by ID"""
    student = db.query(Student).filter(Student.id == student_id).first()
    if not student:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Student not found"
        )
    
    # Check and reset if needed
    if should_reset_credits(student):
        reset_student_credits(db, student)
    
    return student

@app.get("/students", response_model=List[StudentResponse])
def get_all_students(db: Session = Depends(get_db)):
    """Get all students"""
    students = db.query(Student).all()
    return students

# ==================== Recognition Endpoints ====================

@app.post("/recognitions", response_model=RecognitionResponse, status_code=status.HTTP_201_CREATED)
def create_recognition(
    sender_id: int,
    recognition: RecognitionCreate,
    db: Session = Depends(get_db)
):
    """Create a recognition (sender recognizes receiver with credits)"""
    # Validate sender
    sender = db.query(Student).filter(Student.id == sender_id).first()
    if not sender:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Sender not found"
        )
    
    # Check and reset sender credits if needed
    if should_reset_credits(sender):
        reset_student_credits(db, sender)
    
    # Validate receiver
    receiver = db.query(Student).filter(Student.id == recognition.receiver_id).first()
    if not receiver:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Receiver not found"
        )
    
    # Business Rules Validation
    # 1. Cannot send to self
    if sender_id == recognition.receiver_id:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Students cannot send credits to themselves"
        )
    
    # 2. Cannot send more than current balance
    if recognition.credits > sender.current_balance:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Insufficient balance. Current balance: {sender.current_balance}, requested: {recognition.credits}"
        )
    
    # 3. Check monthly sending limit
    current_month = get_current_month_year()
    monthly_sent = db.query(func.sum(Recognition.credits)).filter(
        and_(
            Recognition.sender_id == sender_id,
            Recognition.month_year == current_month
        )
    ).scalar() or 0
    
    if monthly_sent + recognition.credits > sender.monthly_sending_limit:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Monthly sending limit exceeded. Limit: {sender.monthly_sending_limit}, already sent: {monthly_sent}, requested: {recognition.credits}"
        )
    
    # Create recognition
    new_recognition = Recognition(
        sender_id=sender_id,
        receiver_id=recognition.receiver_id,
        credits=recognition.credits,
        message=recognition.message,
        month_year=current_month
    )
    db.add(new_recognition)
    
    # Update balances
    sender.current_balance -= recognition.credits
    receiver.current_balance += recognition.credits
    
    db.commit()
    db.refresh(new_recognition)
    
    # Get endorsement count
    endorsement_count = db.query(func.count(Endorsement.id)).filter(
        Endorsement.recognition_id == new_recognition.id
    ).scalar() or 0
    
    response = RecognitionResponse(
        id=new_recognition.id,
        sender_id=new_recognition.sender_id,
        receiver_id=new_recognition.receiver_id,
        credits=new_recognition.credits,
        message=new_recognition.message,
        created_at=new_recognition.created_at,
        endorsement_count=endorsement_count
    )
    
    return response

@app.get("/recognitions/{recognition_id}", response_model=RecognitionResponse)
def get_recognition(recognition_id: int, db: Session = Depends(get_db)):
    """Get recognition by ID"""
    recognition = db.query(Recognition).filter(Recognition.id == recognition_id).first()
    if not recognition:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Recognition not found"
        )
    
    endorsement_count = db.query(func.count(Endorsement.id)).filter(
        Endorsement.recognition_id == recognition_id
    ).scalar() or 0
    
    response = RecognitionResponse(
        id=recognition.id,
        sender_id=recognition.sender_id,
        receiver_id=recognition.receiver_id,
        credits=recognition.credits,
        message=recognition.message,
        created_at=recognition.created_at,
        endorsement_count=endorsement_count
    )
    
    return response

@app.get("/recognitions", response_model=List[RecognitionResponse])
def get_all_recognitions(db: Session = Depends(get_db)):
    """Get all recognitions"""
    recognitions = db.query(Recognition).all()
    result = []
    for rec in recognitions:
        endorsement_count = db.query(func.count(Endorsement.id)).filter(
            Endorsement.recognition_id == rec.id
        ).scalar() or 0
        result.append(RecognitionResponse(
            id=rec.id,
            sender_id=rec.sender_id,
            receiver_id=rec.receiver_id,
            credits=rec.credits,
            message=rec.message,
            created_at=rec.created_at,
            endorsement_count=endorsement_count
        ))
    return result

# ==================== Endorsement Endpoints ====================

@app.post("/endorsements", response_model=EndorsementResponse, status_code=status.HTTP_201_CREATED)
def create_endorsement(
    endorser_id: int,
    endorsement: EndorsementCreate,
    db: Session = Depends(get_db)
):
    """Create an endorsement (like/cheer for a recognition)"""
    # Validate endorser
    endorser = db.query(Student).filter(Student.id == endorser_id).first()
    if not endorser:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Endorser not found"
        )
    
    # Validate recognition
    recognition = db.query(Recognition).filter(Recognition.id == endorsement.recognition_id).first()
    if not recognition:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Recognition not found"
        )
    
    # Business Rule: Each endorser can endorse a recognition only once
    existing_endorsement = db.query(Endorsement).filter(
        and_(
            Endorsement.recognition_id == endorsement.recognition_id,
            Endorsement.endorser_id == endorser_id
        )
    ).first()
    
    if existing_endorsement:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="You have already endorsed this recognition"
        )
    
    # Create endorsement
    new_endorsement = Endorsement(
        recognition_id=endorsement.recognition_id,
        endorser_id=endorser_id
    )
    db.add(new_endorsement)
    db.commit()
    db.refresh(new_endorsement)
    
    return new_endorsement

@app.get("/endorsements/{endorsement_id}", response_model=EndorsementResponse)
def get_endorsement(endorsement_id: int, db: Session = Depends(get_db)):
    """Get endorsement by ID"""
    endorsement = db.query(Endorsement).filter(Endorsement.id == endorsement_id).first()
    if not endorsement:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Endorsement not found"
        )
    return endorsement

# ==================== Redemption Endpoints ====================

@app.post("/redemptions", response_model=RedemptionResponse, status_code=status.HTTP_201_CREATED)
def create_redemption(
    student_id: int,
    redemption: RedemptionCreate,
    db: Session = Depends(get_db)
):
    """Redeem credits for voucher (₹5 per credit)"""
    # Validate student
    student = db.query(Student).filter(Student.id == student_id).first()
    if not student:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Student not found"
        )
    
    # Check and reset if needed
    if should_reset_credits(student):
        reset_student_credits(db, student)
    
    # Business Rules Validation
    # 1. Cannot redeem more than current balance
    if redemption.credits_redeemed > student.current_balance:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Insufficient balance. Current balance: {student.current_balance}, requested: {redemption.credits_redeemed}"
        )
    
    # 2. Must redeem at least 1 credit
    if redemption.credits_redeemed <= 0:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Credits to redeem must be greater than 0"
        )
    
    # Calculate voucher amount (₹5 per credit)
    voucher_amount = redemption.credits_redeemed * 5
    
    # Create redemption
    new_redemption = Redemption(
        student_id=student_id,
        credits_redeemed=redemption.credits_redeemed,
        voucher_amount=voucher_amount
    )
    db.add(new_redemption)
    
    # Permanently deduct credits
    student.current_balance -= redemption.credits_redeemed
    
    db.commit()
    db.refresh(new_redemption)
    
    return new_redemption

@app.get("/redemptions/{redemption_id}", response_model=RedemptionResponse)
def get_redemption(redemption_id: int, db: Session = Depends(get_db)):
    """Get redemption by ID"""
    redemption = db.query(Redemption).filter(Redemption.id == redemption_id).first()
    if not redemption:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Redemption not found"
        )
    return redemption

@app.get("/students/{student_id}/redemptions", response_model=List[RedemptionResponse])
def get_student_redemptions(student_id: int, db: Session = Depends(get_db)):
    """Get all redemptions for a student"""
    student = db.query(Student).filter(Student.id == student_id).first()
    if not student:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Student not found"
        )
    
    redemptions = db.query(Redemption).filter(Redemption.student_id == student_id).all()
    return redemptions

# ==================== Leaderboard Endpoint ====================

@app.get("/leaderboard", response_model=List[LeaderboardEntry])
def get_leaderboard(limit: Optional[int] = 10, db: Session = Depends(get_db)):
    """Get leaderboard of top recipients ranked by total credits received"""
    # Get all students who have received recognitions
    students_with_recognitions = db.query(Recognition.receiver_id).distinct().subquery()
    
    # Query to get total credits, recognitions, and endorsements per student
    leaderboard = db.query(
        Student.id.label('student_id'),
        Student.name.label('student_name'),
        func.coalesce(func.sum(Recognition.credits), 0).label('total_credits_received'),
        func.count(Recognition.id.distinct()).label('total_recognitions_received'),
        func.coalesce(func.count(Endorsement.id.distinct()), 0).label('total_endorsements_received')
    ).join(students_with_recognitions, Student.id == students_with_recognitions.c.receiver_id)\
     .outerjoin(Recognition, Student.id == Recognition.receiver_id)\
     .outerjoin(Endorsement, Recognition.id == Endorsement.recognition_id)\
     .group_by(Student.id, Student.name)\
     .having(func.coalesce(func.sum(Recognition.credits), 0) > 0)\
     .order_by(
         func.coalesce(func.sum(Recognition.credits), 0).desc(),
         Student.id.asc()
     ).limit(limit).all()
    
    result = []
    for entry in leaderboard:
        result.append(LeaderboardEntry(
            student_id=entry.student_id,
            student_name=entry.student_name,
            total_credits_received=int(entry.total_credits_received),
            total_recognitions_received=int(entry.total_recognitions_received),
            total_endorsements_received=int(entry.total_endorsements_received)
        ))
    
    return result

# ==================== Credit Reset Endpoint (Manual) ====================

@app.post("/credits/reset", status_code=status.HTTP_200_OK)
def manual_reset_credits(db: Session = Depends(get_db)):
    """Manually trigger credit reset for all students (useful for testing)"""
    check_and_reset_all_credits(db)
    return {"message": "Credits reset completed for all eligible students"}

# ==================== Health Check ====================

@app.get("/")
def root():
    """Health check endpoint"""
    return {"message": "Boostly API is running", "version": "1.0.0"}


```


Fixing the leaderboard query to handle aggregations correctly:


```python
from fastapi import FastAPI, Depends, HTTPException, status
from sqlalchemy.orm import Session
from sqlalchemy import func, and_, or_
from datetime import datetime
from typing import List, Optional

from database import Base, engine, get_db
from models import Student, Recognition, Endorsement, Redemption
from schemas import (
    StudentCreate, StudentResponse,
    RecognitionCreate, RecognitionResponse,
    EndorsementCreate, EndorsementResponse,
    RedemptionCreate, RedemptionResponse,
    LeaderboardEntry
)
from utils import get_current_month_year, check_and_reset_all_credits, should_reset_credits, reset_student_credits

# Create database tables
Base.metadata.create_all(bind=engine)

app = FastAPI(title="Boostly API", description="Boost morale, one kudos at a time", version="1.0.0")

# Middleware to check and reset credits on each request
@app.middleware("http")
async def reset_credits_middleware(request, call_next):
    db = next(get_db())
    try:
        check_and_reset_all_credits(db)
    finally:
        db.close()
    response = await call_next(request)
    return response

# ==================== Student Endpoints ====================

@app.post("/students", response_model=StudentResponse, status_code=status.HTTP_201_CREATED)
def create_student(student: StudentCreate, db: Session = Depends(get_db)):
    """Create a new student"""
    # Check if email already exists
    existing_student = db.query(Student).filter(Student.email == student.email).first()
    if existing_student:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Student with this email already exists"
        )
    
    new_student = Student(
        name=student.name,
        email=student.email,
        current_balance=100,
        monthly_sending_limit=100,
        last_reset_date=datetime.now()
    )
    db.add(new_student)
    db.commit()
    db.refresh(new_student)
    return new_student

@app.get("/students/{student_id}", response_model=StudentResponse)
def get_student(student_id: int, db: Session = Depends(get_db)):
    """Get student by ID"""
    student = db.query(Student).filter(Student.id == student_id).first()
    if not student:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Student not found"
        )
    
    # Check and reset if needed
    if should_reset_credits(student):
        reset_student_credits(db, student)
    
    return student

@app.get("/students", response_model=List[StudentResponse])
def get_all_students(db: Session = Depends(get_db)):
    """Get all students"""
    students = db.query(Student).all()
    return students

# ==================== Recognition Endpoints ====================

@app.post("/recognitions", response_model=RecognitionResponse, status_code=status.HTTP_201_CREATED)
def create_recognition(
    sender_id: int,
    recognition: RecognitionCreate,
    db: Session = Depends(get_db)
):
    """Create a recognition (sender recognizes receiver with credits)"""
    # Validate sender
    sender = db.query(Student).filter(Student.id == sender_id).first()
    if not sender:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Sender not found"
        )
    
    # Check and reset sender credits if needed
    if should_reset_credits(sender):
        reset_student_credits(db, sender)
    
    # Validate receiver
    receiver = db.query(Student).filter(Student.id == recognition.receiver_id).first()
    if not receiver:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Receiver not found"
        )
    
    # Business Rules Validation
    # 1. Cannot send to self
    if sender_id == recognition.receiver_id:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Students cannot send credits to themselves"
        )
    
    # 2. Cannot send more than current balance
    if recognition.credits > sender.current_balance:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Insufficient balance. Current balance: {sender.current_balance}, requested: {recognition.credits}"
        )
    
    # 3. Check monthly sending limit
    current_month = get_current_month_year()
    monthly_sent = db.query(func.sum(Recognition.credits)).filter(
        and_(
            Recognition.sender_id == sender_id,
            Recognition.month_year == current_month
        )
    ).scalar() or 0
    
    if monthly_sent + recognition.credits > sender.monthly_sending_limit:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Monthly sending limit exceeded. Limit: {sender.monthly_sending_limit}, already sent: {monthly_sent}, requested: {recognition.credits}"
        )
    
    # Create recognition
    new_recognition = Recognition(
        sender_id=sender_id,
        receiver_id=recognition.receiver_id,
        credits=recognition.credits,
        message=recognition.message,
        month_year=current_month
    )
    db.add(new_recognition)
    
    # Update balances
    sender.current_balance -= recognition.credits
    receiver.current_balance += recognition.credits
    
    db.commit()
    db.refresh(new_recognition)
    
    # Get endorsement count
    endorsement_count = db.query(func.count(Endorsement.id)).filter(
        Endorsement.recognition_id == new_recognition.id
    ).scalar() or 0
    
    response = RecognitionResponse(
        id=new_recognition.id,
        sender_id=new_recognition.sender_id,
        receiver_id=new_recognition.receiver_id,
        credits=new_recognition.credits,
        message=new_recognition.message,
        created_at=new_recognition.created_at,
        endorsement_count=endorsement_count
    )
    
    return response

@app.get("/recognitions/{recognition_id}", response_model=RecognitionResponse)
def get_recognition(recognition_id: int, db: Session = Depends(get_db)):
    """Get recognition by ID"""
    recognition = db.query(Recognition).filter(Recognition.id == recognition_id).first()
    if not recognition:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Recognition not found"
        )
    
    endorsement_count = db.query(func.count(Endorsement.id)).filter(
        Endorsement.recognition_id == recognition_id
    ).scalar() or 0
    
    response = RecognitionResponse(
        id=recognition.id,
        sender_id=recognition.sender_id,
        receiver_id=recognition.receiver_id,
        credits=recognition.credits,
        message=recognition.message,
        created_at=recognition.created_at,
        endorsement_count=endorsement_count
    )
    
    return response

@app.get("/recognitions", response_model=List[RecognitionResponse])
def get_all_recognitions(db: Session = Depends(get_db)):
    """Get all recognitions"""
    recognitions = db.query(Recognition).all()
    result = []
    for rec in recognitions:
        endorsement_count = db.query(func.count(Endorsement.id)).filter(
            Endorsement.recognition_id == rec.id
        ).scalar() or 0
        result.append(RecognitionResponse(
            id=rec.id,
            sender_id=rec.sender_id,
            receiver_id=rec.receiver_id,
            credits=rec.credits,
            message=rec.message,
            created_at=rec.created_at,
            endorsement_count=endorsement_count
        ))
    return result

# ==================== Endorsement Endpoints ====================

@app.post("/endorsements", response_model=EndorsementResponse, status_code=status.HTTP_201_CREATED)
def create_endorsement(
    endorser_id: int,
    endorsement: EndorsementCreate,
    db: Session = Depends(get_db)
):
    """Create an endorsement (like/cheer for a recognition)"""
    # Validate endorser
    endorser = db.query(Student).filter(Student.id == endorser_id).first()
    if not endorser:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Endorser not found"
        )
    
    # Validate recognition
    recognition = db.query(Recognition).filter(Recognition.id == endorsement.recognition_id).first()
    if not recognition:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Recognition not found"
        )
    
    # Business Rule: Each endorser can endorse a recognition only once
    existing_endorsement = db.query(Endorsement).filter(
        and_(
            Endorsement.recognition_id == endorsement.recognition_id,
            Endorsement.endorser_id == endorser_id
        )
    ).first()
    
    if existing_endorsement:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="You have already endorsed this recognition"
        )
    
    # Create endorsement
    new_endorsement = Endorsement(
        recognition_id=endorsement.recognition_id,
        endorser_id=endorser_id
    )
    db.add(new_endorsement)
    db.commit()
    db.refresh(new_endorsement)
    
    return new_endorsement

@app.get("/endorsements/{endorsement_id}", response_model=EndorsementResponse)
def get_endorsement(endorsement_id: int, db: Session = Depends(get_db)):
    """Get endorsement by ID"""
    endorsement = db.query(Endorsement).filter(Endorsement.id == endorsement_id).first()
    if not endorsement:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Endorsement not found"
        )
    return endorsement

# ==================== Redemption Endpoints ====================

@app.post("/redemptions", response_model=RedemptionResponse, status_code=status.HTTP_201_CREATED)
def create_redemption(
    student_id: int,
    redemption: RedemptionCreate,
    db: Session = Depends(get_db)
):
    """Redeem credits for voucher (₹5 per credit)"""
    # Validate student
    student = db.query(Student).filter(Student.id == student_id).first()
    if not student:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Student not found"
        )
    
    # Check and reset if needed
    if should_reset_credits(student):
        reset_student_credits(db, student)
    
    # Business Rules Validation
    # 1. Cannot redeem more than current balance
    if redemption.credits_redeemed > student.current_balance:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Insufficient balance. Current balance: {student.current_balance}, requested: {redemption.credits_redeemed}"
        )
    
    # 2. Must redeem at least 1 credit
    if redemption.credits_redeemed <= 0:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Credits to redeem must be greater than 0"
        )
    
    # Calculate voucher amount (₹5 per credit)
    voucher_amount = redemption.credits_redeemed * 5
    
    # Create redemption
    new_redemption = Redemption(
        student_id=student_id,
        credits_redeemed=redemption.credits_redeemed,
        voucher_amount=voucher_amount
    )
    db.add(new_redemption)
    
    # Permanently deduct credits
    student.current_balance -= redemption.credits_redeemed
    
    db.commit()
    db.refresh(new_redemption)
    
    return new_redemption

@app.get("/redemptions/{redemption_id}", response_model=RedemptionResponse)
def get_redemption(redemption_id: int, db: Session = Depends(get_db)):
    """Get redemption by ID"""
    redemption = db.query(Redemption).filter(Redemption.id == redemption_id).first()
    if not redemption:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Redemption not found"
        )
    return redemption

@app.get("/students/{student_id}/redemptions", response_model=List[RedemptionResponse])
def get_student_redemptions(student_id: int, db: Session = Depends(get_db)):
    """Get all redemptions for a student"""
    student = db.query(Student).filter(Student.id == student_id).first()
    if not student:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Student not found"
        )
    
    redemptions = db.query(Redemption).filter(Redemption.student_id == student_id).all()
    return redemptions

# ==================== Leaderboard Endpoint ====================

@app.get("/leaderboard", response_model=List[LeaderboardEntry])
def get_leaderboard(limit: Optional[int] = 10, db: Session = Depends(get_db)):
    """Get leaderboard of top recipients ranked by total credits received"""
    # Query to get total credits received per student
    credits_query = db.query(
        Recognition.receiver_id,
        func.sum(Recognition.credits).label('total_credits')
    ).group_by(Recognition.receiver_id).subquery()
    
    # Query to get total recognitions received per student
    recognitions_query = db.query(
        Recognition.receiver_id,
        func.count(Recognition.id).label('total_recognitions')
    ).group_by(Recognition.receiver_id).subquery()
    
    # Query to get total endorsements received per student (across all their recognitions)
    endorsements_query = db.query(
        Recognition.receiver_id,
        func.count(Endorsement.id).label('total_endorsements')
    ).join(Endorsement, Recognition.id == Endorsement.recognition_id)\
     .group_by(Recognition.receiver_id).subquery()
    
    # Main query joining all data
    leaderboard = db.query(
        Student.id.label('student_id'),
        Student.name.label('student_name'),
        func.coalesce(credits_query.c.total_credits, 0).label('total_credits_received'),
        func.coalesce(recognitions_query.c.total_recognitions, 0).label('total_recognitions_received'),
        func.coalesce(endorsements_query.c.total_endorsements, 0).label('total_endorsements_received')
    ).join(credits_query, Student.id == credits_query.c.receiver_id)\
     .outerjoin(recognitions_query, Student.id == recognitions_query.c.receiver_id)\
     .outerjoin(endorsements_query, Student.id == endorsements_query.c.receiver_id)\
     .order_by(
         func.coalesce(credits_query.c.total_credits, 0).desc(),
         Student.id.asc()
     ).limit(limit).all()
    
    result = []
    for entry in leaderboard:
        result.append(LeaderboardEntry(
            student_id=entry.student_id,
            student_name=entry.student_name,
            total_credits_received=int(entry.total_credits_received),
            total_recognitions_received=int(entry.total_recognitions_received),
            total_endorsements_received=int(entry.total_endorsements_received)
        ))
    
    return result

# ==================== Credit Reset Endpoint (Manual) ====================

@app.post("/credits/reset", status_code=status.HTTP_200_OK)
def manual_reset_credits(db: Session = Depends(get_db)):
    """Manually trigger credit reset for all students (useful for testing)"""
    check_and_reset_all_credits(db)
    return {"message": "Credits reset completed for all eligible students"}

# ==================== Health Check ====================

@app.get("/")
def root():
    """Health check endpoint"""
    return {"message": "Boostly API is running", "version": "1.0.0"}


```


Verifying the final structure and preparing a summary:



Removing unused imports:


```python
from fastapi import FastAPI, Depends, HTTPException, status
from sqlalchemy.orm import Session
from sqlalchemy import func, and_
from datetime import datetime
from typing import List, Optional

from database import Base, engine, get_db
from models import Student, Recognition, Endorsement, Redemption
from schemas import (
    StudentCreate, StudentResponse,
    RecognitionCreate, RecognitionResponse,
    EndorsementCreate, EndorsementResponse,
    RedemptionCreate, RedemptionResponse,
    LeaderboardEntry
)
from utils import get_current_month_year, check_and_reset_all_credits, should_reset_credits, reset_student_credits

# Create database tables
Base.metadata.create_all(bind=engine)

app = FastAPI(title="Boostly API", description="Boost morale, one kudos at a time", version="1.0.0")

# Middleware to check and reset credits on each request
@app.middleware("http")
async def reset_credits_middleware(request, call_next):
    db = next(get_db())
    try:
        check_and_reset_all_credits(db)
    finally:
        db.close()
    response = await call_next(request)
    return response

# ==================== Student Endpoints ====================

@app.post("/students", response_model=StudentResponse, status_code=status.HTTP_201_CREATED)
def create_student(student: StudentCreate, db: Session = Depends(get_db)):
    """Create a new student"""
    # Check if email already exists
    existing_student = db.query(Student).filter(Student.email == student.email).first()
    if existing_student:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Student with this email already exists"
        )
    
    new_student = Student(
        name=student.name,
        email=student.email,
        current_balance=100,
        monthly_sending_limit=100,
        last_reset_date=datetime.now()
    )
    db.add(new_student)
    db.commit()
    db.refresh(new_student)
    return new_student

@app.get("/students/{student_id}", response_model=StudentResponse)
def get_student(student_id: int, db: Session = Depends(get_db)):
    """Get student by ID"""
    student = db.query(Student).filter(Student.id == student_id).first()
    if not student:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Student not found"
        )
    
    # Check and reset if needed
    if should_reset_credits(student):
        reset_student_credits(db, student)
    
    return student

@app.get("/students", response_model=List[StudentResponse])
def get_all_students(db: Session = Depends(get_db)):
    """Get all students"""
    students = db.query(Student).all()
    return students

# ==================== Recognition Endpoints ====================

@app.post("/recognitions", response_model=RecognitionResponse, status_code=status.HTTP_201_CREATED)
def create_recognition(
    sender_id: int,
    recognition: RecognitionCreate,
    db: Session = Depends(get_db)
):
    """Create a recognition (sender recognizes receiver with credits)"""
    # Validate sender
    sender = db.query(Student).filter(Student.id == sender_id).first()
    if not sender:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Sender not found"
        )
    
    # Check and reset sender credits if needed
    if should_reset_credits(sender):
        reset_student_credits(db, sender)
    
    # Validate receiver
    receiver = db.query(Student).filter(Student.id == recognition.receiver_id).first()
    if not receiver:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Receiver not found"
        )
    
    # Business Rules Validation
    # 1. Cannot send to self
    if sender_id == recognition.receiver_id:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Students cannot send credits to themselves"
        )
    
    # 2. Cannot send more than current balance
    if recognition.credits > sender.current_balance:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Insufficient balance. Current balance: {sender.current_balance}, requested: {recognition.credits}"
        )
    
    # 3. Check monthly sending limit
    current_month = get_current_month_year()
    monthly_sent = db.query(func.sum(Recognition.credits)).filter(
        and_(
            Recognition.sender_id == sender_id,
            Recognition.month_year == current_month
        )
    ).scalar() or 0
    
    if monthly_sent + recognition.credits > sender.monthly_sending_limit:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Monthly sending limit exceeded. Limit: {sender.monthly_sending_limit}, already sent: {monthly_sent}, requested: {recognition.credits}"
        )
    
    # Create recognition
    new_recognition = Recognition(
        sender_id=sender_id,
        receiver_id=recognition.receiver_id,
        credits=recognition.credits,
        message=recognition.message,
        month_year=current_month
    )
    db.add(new_recognition)
    
    # Update balances
    sender.current_balance -= recognition.credits
    receiver.current_balance += recognition.credits
    
    db.commit()
    db.refresh(new_recognition)
    
    # Get endorsement count
    endorsement_count = db.query(func.count(Endorsement.id)).filter(
        Endorsement.recognition_id == new_recognition.id
    ).scalar() or 0
    
    response = RecognitionResponse(
        id=new_recognition.id,
        sender_id=new_recognition.sender_id,
        receiver_id=new_recognition.receiver_id,
        credits=new_recognition.credits,
        message=new_recognition.message,
        created_at=new_recognition.created_at,
        endorsement_count=endorsement_count
    )
    
    return response

@app.get("/recognitions/{recognition_id}", response_model=RecognitionResponse)
def get_recognition(recognition_id: int, db: Session = Depends(get_db)):
    """Get recognition by ID"""
    recognition = db.query(Recognition).filter(Recognition.id == recognition_id).first()
    if not recognition:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Recognition not found"
        )
    
    endorsement_count = db.query(func.count(Endorsement.id)).filter(
        Endorsement.recognition_id == recognition_id
    ).scalar() or 0
    
    response = RecognitionResponse(
        id=recognition.id,
        sender_id=recognition.sender_id,
        receiver_id=recognition.receiver_id,
        credits=recognition.credits,
        message=recognition.message,
        created_at=recognition.created_at,
        endorsement_count=endorsement_count
    )
    
    return response

@app.get("/recognitions", response_model=List[RecognitionResponse])
def get_all_recognitions(db: Session = Depends(get_db)):
    """Get all recognitions"""
    recognitions = db.query(Recognition).all()
    result = []
    for rec in recognitions:
        endorsement_count = db.query(func.count(Endorsement.id)).filter(
            Endorsement.recognition_id == rec.id
        ).scalar() or 0
        result.append(RecognitionResponse(
            id=rec.id,
            sender_id=rec.sender_id,
            receiver_id=rec.receiver_id,
            credits=rec.credits,
            message=rec.message,
            created_at=rec.created_at,
            endorsement_count=endorsement_count
        ))
    return result

# ==================== Endorsement Endpoints ====================

@app.post("/endorsements", response_model=EndorsementResponse, status_code=status.HTTP_201_CREATED)
def create_endorsement(
    endorser_id: int,
    endorsement: EndorsementCreate,
    db: Session = Depends(get_db)
):
    """Create an endorsement (like/cheer for a recognition)"""
    # Validate endorser
    endorser = db.query(Student).filter(Student.id == endorser_id).first()
    if not endorser:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Endorser not found"
        )
    
    # Validate recognition
    recognition = db.query(Recognition).filter(Recognition.id == endorsement.recognition_id).first()
    if not recognition:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Recognition not found"
        )
    
    # Business Rule: Each endorser can endorse a recognition only once
    existing_endorsement = db.query(Endorsement).filter(
        and_(
            Endorsement.recognition_id == endorsement.recognition_id,
            Endorsement.endorser_id == endorser_id
        )
    ).first()
    
    if existing_endorsement:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="You have already endorsed this recognition"
        )
    
    # Create endorsement
    new_endorsement = Endorsement(
        recognition_id=endorsement.recognition_id,
        endorser_id=endorser_id
    )
    db.add(new_endorsement)
    db.commit()
    db.refresh(new_endorsement)
    
    return new_endorsement

@app.get("/endorsements/{endorsement_id}", response_model=EndorsementResponse)
def get_endorsement(endorsement_id: int, db: Session = Depends(get_db)):
    """Get endorsement by ID"""
    endorsement = db.query(Endorsement).filter(Endorsement.id == endorsement_id).first()
    if not endorsement:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Endorsement not found"
        )
    return endorsement

# ==================== Redemption Endpoints ====================

@app.post("/redemptions", response_model=RedemptionResponse, status_code=status.HTTP_201_CREATED)
def create_redemption(
    student_id: int,
    redemption: RedemptionCreate,
    db: Session = Depends(get_db)
):
    """Redeem credits for voucher (₹5 per credit)"""
    # Validate student
    student = db.query(Student).filter(Student.id == student_id).first()
    if not student:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Student not found"
        )
    
    # Check and reset if needed
    if should_reset_credits(student):
        reset_student_credits(db, student)
    
    # Business Rules Validation
    # 1. Cannot redeem more than current balance
    if redemption.credits_redeemed > student.current_balance:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Insufficient balance. Current balance: {student.current_balance}, requested: {redemption.credits_redeemed}"
        )
    
    # 2. Must redeem at least 1 credit
    if redemption.credits_redeemed <= 0:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Credits to redeem must be greater than 0"
        )
    
    # Calculate voucher amount (₹5 per credit)
    voucher_amount = redemption.credits_redeemed * 5
    
    # Create redemption
    new_redemption = Redemption(
        student_id=student_id,
        credits_redeemed=redemption.credits_redeemed,
        voucher_amount=voucher_amount
    )
    db.add(new_redemption)
    
    # Permanently deduct credits
    student.current_balance -= redemption.credits_redeemed
    
    db.commit()
    db.refresh(new_redemption)
    
    return new_redemption

@app.get("/redemptions/{redemption_id}", response_model=RedemptionResponse)
def get_redemption(redemption_id: int, db: Session = Depends(get_db)):
    """Get redemption by ID"""
    redemption = db.query(Redemption).filter(Redemption.id == redemption_id).first()
    if not redemption:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Redemption not found"
        )
    return redemption

@app.get("/students/{student_id}/redemptions", response_model=List[RedemptionResponse])
def get_student_redemptions(student_id: int, db: Session = Depends(get_db)):
    """Get all redemptions for a student"""
    student = db.query(Student).filter(Student.id == student_id).first()
    if not student:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Student not found"
        )
    
    redemptions = db.query(Redemption).filter(Redemption.student_id == student_id).all()
    return redemptions

# ==================== Leaderboard Endpoint ====================

@app.get("/leaderboard", response_model=List[LeaderboardEntry])
def get_leaderboard(limit: Optional[int] = 10, db: Session = Depends(get_db)):
    """Get leaderboard of top recipients ranked by total credits received"""
    # Query to get total credits received per student
    credits_query = db.query(
        Recognition.receiver_id,
        func.sum(Recognition.credits).label('total_credits')
    ).group_by(Recognition.receiver_id).subquery()
    
    # Query to get total recognitions received per student
    recognitions_query = db.query(
        Recognition.receiver_id,
        func.count(Recognition.id).label('total_recognitions')
    ).group_by(Recognition.receiver_id).subquery()
    
    # Query to get total endorsements received per student (across all their recognitions)
    endorsements_query = db.query(
        Recognition.receiver_id,
        func.count(Endorsement.id).label('total_endorsements')
    ).join(Endorsement, Recognition.id == Endorsement.recognition_id)\
     .group_by(Recognition.receiver_id).subquery()
    
    # Main query joining all data
    leaderboard = db.query(
        Student.id.label('student_id'),
        Student.name.label('student_name'),
        func.coalesce(credits_query.c.total_credits, 0).label('total_credits_received'),
        func.coalesce(recognitions_query.c.total_recognitions, 0).label('total_recognitions_received'),
        func.coalesce(endorsements_query.c.total_endorsements, 0).label('total_endorsements_received')
    ).join(credits_query, Student.id == credits_query.c.receiver_id)\
     .outerjoin(recognitions_query, Student.id == recognitions_query.c.receiver_id)\
     .outerjoin(endorsements_query, Student.id == endorsements_query.c.receiver_id)\
     .order_by(
         func.coalesce(credits_query.c.total_credits, 0).desc(),
         Student.id.asc()
     ).limit(limit).all()
    
    result = []
    for entry in leaderboard:
        result.append(LeaderboardEntry(
            student_id=entry.student_id,
            student_name=entry.student_name,
            total_credits_received=int(entry.total_credits_received),
            total_recognitions_received=int(entry.total_recognitions_received),
            total_endorsements_received=int(entry.total_endorsements_received)
        ))
    
    return result

# ==================== Credit Reset Endpoint (Manual) ====================

@app.post("/credits/reset", status_code=status.HTTP_200_OK)
def manual_reset_credits(db: Session = Depends(get_db)):
    """Manually trigger credit reset for all students (useful for testing)"""
    check_and_reset_all_credits(db)
    return {"message": "Credits reset completed for all eligible students"}

# ==================== Health Check ====================

@app.get("/")
def root():
    """Health check endpoint"""
    return {"message": "Boostly API is running", "version": "1.0.0"}


```

```python
from datetime import datetime
from sqlalchemy.orm import Session
from models import Student

def get_current_month_year() -> str:
    """Get current month-year string in YYYY-MM format"""
    return datetime.now().strftime("%Y-%m")

def should_reset_credits(student: Student) -> bool:
    """Check if student's credits should be reset based on last reset date"""
    current_date = datetime.now()
    last_reset = student.last_reset_date
    
    # Check if we're in a different month
    if current_date.year > last_reset.year or \
       (current_date.year == last_reset.year and current_date.month > last_reset.month):
        return True
    return False

def reset_student_credits(db: Session, student: Student):
    """Reset student credits with carry-forward logic"""
    # Calculate carry-forward (max 50 credits)
    unused_credits = student.current_balance
    carry_forward = min(unused_credits, 50)
    
    # Reset to 100 + carry_forward
    student.current_balance = 100 + carry_forward
    student.monthly_sending_limit = 100
    student.last_reset_date = datetime.now()
    
    db.commit()
    db.refresh(student)

def check_and_reset_all_credits(db: Session):
    """Check all students and reset credits if needed"""
    students = db.query(Student).all()
    for student in students:
        if should_reset_credits(student):
            reset_student_credits(db, student)


```


## Implementation complete

### Project structure
```
src/
├── main.py              # FastAPI application with all endpoints
├── models.py            # Database models (Student, Recognition, Endorsement, Redemption)
├── schemas.py           # Pydantic request/response schemas
├── database.py          # Database configuration (SQLite)
├── utils.py             # Utility functions (credit reset logic)
├── requirements.txt     # Python dependencies
└── readme.md           # Complete API documentation

test-cases/
└── test-cases.txt      # Comprehensive testing instructions
```

### Features implemented

1. Core functionality:
   - Recognition: Students can recognize peers and transfer credits
   - Endorsements: Students can endorse (like) recognition entries
   - Redemption: Students can redeem credits for vouchers (₹5 per credit)

2. Step-up challenges:
   - Credit reset: Automatic monthly reset with carry-forward (max 50 credits)
   - Leaderboard: Top recipients ranked by credits received

3. Business rules enforced:
   - 100 credits per month per student
   - No self-recognition
   - Monthly sending limit of 100 credits
   - Balance validation
   - One endorsement per endorser per recognition
   - Permanent credit deduction on redemption

### To run the application

1. Navigate to src directory:
   ```bash
   cd src
   ```

2. Create virtual environment (recommended):
   ```bash
   python3 -m venv venv
   source venv/bin/activate  # On Windows: venv\Scripts\activate
   ```

3. Install dependencies:
   ```bash
   pip install -r requirements.txt
   ```

4. Run the application:
   ```bash
   uvicorn main:app --reload
   ```

5. Access the API:
   - API: `http://localhost:8000`
   - Swagger UI: `http://localhost:8000/docs`
   - ReDoc: `http://localhost:8000/redoc`

### Documentation

- `src/readme.md`: Setup instructions, API endpoints, sample requests
- `test-cases/test-cases.txt`: Testing instructions for all features

### Next steps

1. Test the application using the instructions in `test-cases/test-cases.txt`
2. Use Swagger UI at `http://localhost:8000/docs` for interactive testing
3. The database (`boostly.db`) will be created automatically in the `src/` directory

The application is ready to run locally. All requirements from the README have been implemented.

```plaintext
src/
├── main.py              # FastAPI application with all endpoints
├── models.py            # Database models (Student, Recognition, Endorsement, Redemption)
├── schemas.py           # Pydantic request/response schemas
├── database.py          # Database configuration (SQLite)
├── utils.py             # Utility functions (credit reset logic)
├── requirements.txt     # Python dependencies
└── readme.md           # Complete API documentation

test-cases/
└── test-cases.txt      # Comprehensive testing instructions
```

```shellscript
   cd src
```

```shellscript
   python3 -m venv venv
   source venv/bin/activate  # On Windows: venv\Scripts\activate
```

```shellscript
   pip install -r requirements.txt
```

```shellscript
   uvicorn main:app --reload
```

---

**User**

@Python (154) fix this import error , if it exists otherwise use a better alternative 

---

**Cursor**


Checking the current setup and fixing the email validation issue:



Fixing the email validation issue. `EmailStr` requires `email-validator`. Adding it to requirements and updating the schema to use a more robust validation approach:


```plaintext
fastapi==0.104.1
uvicorn==0.24.0
sqlalchemy==2.0.23
pydantic==2.5.0
email-validator==2.1.0
python-dateutil==2.8.2


```


Added `email-validator` to requirements. This is the standard dependency for Pydantic's `EmailStr`.

If you prefer to avoid an external dependency, we can switch to a regex-based validator. Keeping the current approach for now since it's standard.

To apply the fix, run:
```bash
pip install -r requirements.txt
```

Or install just the email validator:
```bash
pip install email-validator
```

The application should now work without the import error. The `EmailStr` type in `schemas.py` will validate email addresses using the `email-validator` package.

Should I also provide an alternative implementation that doesn't require `email-validator`?

```shellscript
pip install -r requirements.txt
```

```shellscript
pip install email-validator
```

